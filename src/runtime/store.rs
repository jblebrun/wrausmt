use super::super::module::*;
use super::super::types::*;
use std::rc::Rc;

/// The WASM Store as described in the specification.
#[derive(Debug)]
pub struct Store {
    // FunctionInstance contain Functions, and thus the code
    // to run. They will be used by execution threads, so 
    // are stored as Rc.
    pub funcs: Vec<Rc<FunctionInstance>>
}

type FuncAddr = u32;


#[derive(Debug)]
pub struct ModuleInstance {
    types: Box<[FunctionType]>,
    exports: Box<[Export]>,
    func_offset: u32
}

impl ModuleInstance {
    pub fn resolve(&self, name: &str) -> Option<&Export> {
        let found = self.exports.into_iter().find(|e| {
            e.name == name
        });

        return found;
    }
}

#[derive(Debug)]
pub struct Export {
    pub name: String,
    pub addr: FuncAddr
}

impl Store {
    pub fn new() -> Store {
        Store {
            funcs: vec![]
        }
    }

    /// Load the provided module into this store.
    /// The module will be consumed by this call, and 
    /// ModuleInstance representing it will be returned.
    pub fn load(&mut self, module: Module) -> Rc<ModuleInstance> {
        // Calculate the address offset for this module.
        // We won't explicity save idx->address mapping, instead
        // it can be generated by adding this offset to the module
        // indices.
        let func_offset = self.funcs.len() as u32;

        let mod_inst = Rc::new(ModuleInstance { 
            // Take the module types from the module for the instance.
            types: module.types,

            func_offset: func_offset,

            // Convert the module exports into runtime exports;
            // this means converting the index values into address
            // values.
            exports: module.exports
                .into_vec()
                .into_iter()
                .map(|e| {
                    Export {
                        name: e.name,
                        addr: e.idx + func_offset
                    }
                }).collect()
        });

        // Append created functions into the store.
        for f in module.funcs.into_vec() {
            self.funcs.push(Rc::new(FunctionInstance {
                module_instance: mod_inst.clone(),
                code: f
            }));
        }

        mod_inst
    }
}

/// A function entry in the store.
#[derive(Debug)]
pub struct FunctionInstance {
    /// The module instance that generated this function instance.
    pub module_instance: Rc<ModuleInstance>,

    /// The list of instructions in the function.
    pub code: Function,
}

impl FunctionInstance {
    pub fn result_arity(&self) -> usize {
        self.module_instance.types[self.code.functype as usize].result.len()
    }
    pub fn params_arity(&self) -> usize {
        self.module_instance.types[self.code.functype as usize].params.len()
    }
}
