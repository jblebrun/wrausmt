use super::super::module::*;
use super::super::types::FunctionType;
use std::rc::Rc;

/// The WASM Store as described in the specification.
#[derive(Debug)]
pub struct Store {
    funcs: Vec<FunctionInstance>
}

type FuncAddr = u32;


#[derive(Debug)]
pub struct ModuleInstance {
    types: Box<[FunctionType]>,
    exports: Box<[Export]>,
    funcOffset: u32
}

impl ModuleInstance {
    pub fn func(&self, idx: FuncIdx) -> FuncAddr { self.funcOffset + idx }

    pub fn resolve(&self, name: &str) -> Option<&Export> {
        let found = self.exports.into_iter().find(|e| {
            e.name == name
        });

        return found;
    }
}

#[derive(Debug)]
pub struct Export {
    pub name: String,
    pub idx: FuncAddr
}

impl Store {
    pub fn new() -> Store {
        Store {
            funcs: vec![]
        }
    }

    /// Load the provided module into this store.
    /// The module will be consumed by this call, and 
    /// ModuleInstance representing it will be returned.
    pub fn load(&mut self, module: Module) -> Rc<ModuleInstance> {
        // Calculate the address offset for this module.
        // We won't explicity save idx->address mapping, instead
        // it can be generated by adding this offset to the module
        // indices.
        let func_offset = self.funcs.len() as u32;

        let mod_inst = Rc::new(ModuleInstance { 
            // Take the module types from the module for the instance.
            types: module.types,

            funcOffset: func_offset,

            // Convert the module exports into runtime exports;
            // this means converting the index values into address
            // values.
            exports: module.exports
                .into_vec()
                .into_iter()
                .map(|e| {
                    Export {
                        name: e.name,
                        idx: e.idx + func_offset
                    }
                }).collect()
        });

        // Append created functions into the store.
        for f in module.funcs.into_vec() {
            self.funcs.push(FunctionInstance {
                moduleInstance: mod_inst.clone(),
                code: f
            });
        }

        mod_inst
    }
}

/// A function entry in the store.
#[derive(Debug)]
pub struct FunctionInstance {
    /// The module instance that generated this function instance.
    pub moduleInstance: Rc<ModuleInstance>,

    /// The list of instructions in the function.
    pub code: Function,
}
